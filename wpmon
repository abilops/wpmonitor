#!/usr/bin/env python3
import time
import urllib
import requests
import datetime
import os
import webbrowser
import re
import ssl
import json

# uses argparse and configparser to decide on functions
import argsconfig
args = argsconfig.getOptions()
# all colours declared here
from colours import *
# functions related to notifications
from notifyme import *
# generic, simple and small functions that don't need args
from functions import *

url = args.url
interval = args.interval
USAG = args.useragent

if (args.filename is None or args.filename == '__new__'):
    fname = "HTMLs/"+url.split('://')[1].replace('/','-')
else:
    fname = args.filename

#returns HTML text of URL
def opn(url):
    try:
        ctx = ssl.create_default_context()
        if args.insecure == True:
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
        req = urllib.request.Request(
            url,
            headers={'User-Agent': USAG})
        with urllib.request.urlopen(req, context=ctx) as page:
            pageText = page.read().decode('utf-8')
        log(lblue + "Page Downloaded")
        return pageText # <--- Removed str if decode is applied
    except Exception as e:
        log(red + "Cannot open URL. Are you connected to the internet? " + str(e) +  white)
        time.sleep(interval/4)
        return '-1'

# is RESPONSIBLE for returning HTML
def getHTML(url):
    pageText = '-1'
    while pageText == '-1':
        pageText = opn(url)
    return stripStupidDeltas(pageText)

def log(text):
    if args.quiet == 0 or text.startswith(red):
        printDate()
        print(text)

def wait(interval):
    if args.quiet != 0:
        print("Waiting for {} more seconds...".format(interval), flush=True)
        time.sleep(interval)
    else:
        for x in range(interval, 0, -1):
            print(clearline + "Waiting for {} more seconds...".format(x), end='', flush=True)
            time.sleep(1)
        print(clearline, end='')

def printHeader():
    if args.quiet != 0:
        return
    os.system('/usr/bin/clear')
    print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")
    print(green + "WEBPAGE MONITOR v1.0" + white)
    print(green + "Not refreshing any more!!" + white)
    print("URL: " + lblue + url + white)
    print("Interval: " + lblue + str(interval) + " seconds" + white)
    print("File: " + lblue + fname + white)
    print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")

def getAttentionAndBrowser(url):
    if args.headless == False:
        # Turn on the screen
        os.system("/usr/bin/xset dpms force on")        
        os.system("/usr/bin/espeak 'Alert! Webpage has changed.' &")
        notify('Webpage Monitor', url + ' has changed. Opening in new browser tab.\nFingers crossed!')
        webbrowser.open_new_tab(url)

# Go to the right directory
abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname)

try:
    printHeader()
    checkEmail(args.email)
    downloadedNewTemplate = False
    if os.path.isfile(fname + ".changed") and args.filename != '__new__':
        os.remove(fname)
        os.rename(fname + ".changed", fname)
        log("Found last change. Using that as template. Fine?")
    elif os.path.isfile(fname) and os.stat(fname).st_size != 0 and args.filename != '__new__':
        log("Template file found. Not creating new one.")
        log("In fact, not even touching it now.")
    else:
        writeFile(fname, getHTML(url))
        downloadedNewTemplate = True
        log("Template file saved" + white);

    while True:
        # Didn't you just download it right now?
        if not downloadedNewTemplate:
            # Get new
            newText = getHTML(url)
        else:
            newText = readFile(fname)
            downloadedNewTemplate=False
        # Read check file
        checkText = readFile(fname)
        if (checkText == newText):
            log(green + "Damn! Nothing has changed yet!" + white)
        else:
            # Write changed to disk
            writeFile(fname+'.changed', newText)
            if args.next != None:
                log("Running next script")
                try:
                    os.system("./{} > /dev/null 2>&1".format(args.next))
                except Exception as e:
                    log(red + "Error running {} {} {}".format(args.next, str(e), white))
            sendPush("{} has changed!".format(url))
            if args.email == None:
                log(red + "WEBPAGE HAS CHANGED! GO CHECK IT NOW" + white)
                getAttentionAndBrowser(url)
                # Try Ctrl-C ing this
                while True:
                    os.system("/usr/bin/aplay {}".format(args.sound))
                    time.sleep(0.1)
                exit()
            # If the user wants email alerts
            else:
                text = config.get('DEFAULT', 'email_text').replace('__url__', url)
                # To, sub, text, html
                # Html needs text too clients choose one of the two.
                print(send_message([config.get('DEFAULT', 'email_to'),args.email], config.get('DEFAULT', 'email_subject').replace('__url__', url) ,text, text + str(newText)))
                log(red + "Sent an email to " + args.email + ". Restarting..." + white)
                # Absorb changes into check file
                # absorb changes into check variabel
                writeFile(fname, newText)
#               checkText = newText
        # Wait for however long
        wait(interval)
except Exception as e:
    log(red + "There is some kind of error (I mean\n" + str(e) + "). Exiting..." + white)
    notify('Webpage Monitor', 'Crashed due to ' + str(e))
    exit()
